package fireball

import (
	"bytes"
	"fmt"
	"html/template"
	"os"
	"path/filepath"
	"strings"
)

// TemplateParser is an interface object that is used to parse HTML templates
type TemplateParser interface {
	Parse() (*template.Template, error)
}

// TemplateParserFunc is a function which implements the TemplateParser interface
type TemplateParserFunc func() (*template.Template, error)

func (tpf TemplateParserFunc) Parse() (*template.Template, error) {
	return tpf()
}

// GlobParser generates a template by recusively searching the specified root directory
// and parses templates that match the specified glob pattern
type GlobParser struct {
	Root  string
	Glob  string
	cache *template.Template
}

// NewGlobParser returns a GlobParser with the specified root and glob pattern
func NewGlobParser(root, glob string) *GlobParser {
	return &GlobParser{
		Root: root,
		Glob: glob,
	}
}

// Parse recursively searches the root directory and parses templates
// that match the specified glob pattern.
// Template names are generated by path/from/root + filename.
//
// For example, if GlobParser.Root == "views", the following template names would be generated:
//  Files:
//    views/
//      index.html
//      partials/
//        login.html
//
//  Template Names:
//    "index.html"
//    "partials/login.html"
func (p *GlobParser) Parse() (*template.Template, error) {
	if p.cache != nil {
		return p.cache, nil
	}

	root := template.New("root")

	walkf := func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if info.IsDir() {
			path = filepath.Join(path, p.Glob)
			current, err := template.ParseGlob(path)
			if err != nil {
				return err
			}

			for _, t := range current.Templates() {
				name := p.generateTemplateName(path, t)

				if _, err := root.AddParseTree(name, t.Tree); err != nil {
					return err
				}
			}
		}

		return nil
	}

	if err := filepath.Walk(p.Root, walkf); err != nil {
		return nil, err
	}

	p.cache = root
	return root, nil
}

func (p *GlobParser) generateTemplateName(path string, t *template.Template) string {
	path = strings.Replace(filepath.Dir(path), "\\", "/", -1)
	path = fmt.Sprintf("%s/%s", path, t.Name())
	name := strings.TrimPrefix(path, p.Root)
	return name
}

// HTML is a helper function that returns a response generated from the given templateName and data
func HTML(parser TemplateParser, status int, templateName string, data interface{}) (*HTTPResponse, error) {
	tmpl, err := parser.Parse()
	if err != nil {
		return nil, err
	}

	var buffer bytes.Buffer
	if err := tmpl.ExecuteTemplate(&buffer, templateName, data); err != nil {
		return nil, err
	}

	response := NewResponse(status, buffer.Bytes(), HTMLHeaders)
	return response, nil
}
